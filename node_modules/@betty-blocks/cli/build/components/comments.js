"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts = __importStar(require("typescript"));
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
const jsdoc = __importStar(require("jsdoc-api"));
/**
 * Retrieves the JSDoc-style comments associated with a specific AST node.
 *
 * Based on ts.getJSDocCommentRanges() from the compiler.
 * https://github.com/microsoft/TypeScript/blob/v3.0.3/src/compiler/utilities.ts#L924
 */
function getJSDocCommentRanges(node, text) {
    const commentRanges = [];
    switch (node.kind) {
        case ts.SyntaxKind.Parameter:
        case ts.SyntaxKind.TypeParameter:
        case ts.SyntaxKind.FunctionExpression:
        case ts.SyntaxKind.ArrowFunction:
        case ts.SyntaxKind.ParenthesizedExpression:
            commentRanges.push(...(ts.getTrailingCommentRanges(text, node.pos) || []));
            break;
        default:
            break;
    }
    commentRanges.push(...(ts.getLeadingCommentRanges(text, node.pos) || []));
    // True if the comment starts with '/**' but not if it is '/**/'
    return commentRanges.filter(comment => text.charCodeAt(comment.pos + 1) ===
        0x2a /* ts.CharacterCodes.asterisk */ &&
        text.charCodeAt(comment.pos + 2) ===
            0x2a /* ts.CharacterCodes.asterisk */ &&
        text.charCodeAt(comment.pos + 3) !== 0x2f /* ts.CharacterCodes.slash */);
}
function walkCompilerAstAndFindComments(node, foundComments) {
    // The TypeScript AST doesn't store code comments directly.  If you want to find *every* comment,
    // you would need to rescan the SourceFile tokens similar to how tsutils.forEachComment() works:
    // https://github.com/ajafff/tsutils/blob/v3.0.0/util/util.ts#L453
    //
    // However, for this demo we are modeling a tool that discovers declarations and then analyzes their doc comments,
    // so we only care about TSDoc that would conventionally be associated with an interesting AST node.
    const buffer = node.getSourceFile().getFullText(); // don't use getText() here!
    // Only consider nodes that are part of a declaration form.  Without this, we could discover
    // the same comment twice (e.g. for a MethodDeclaration and its PublicKeyword).
    // Find "/** */" style comments associated with this node.
    // Note that this reinvokes the compiler's scanner -- the result is not cached.
    const comments = getJSDocCommentRanges(node, buffer);
    comments.forEach(c => {
        const source = buffer.slice(c.pos, c.end);
        const comment = jsdoc.explainSync({ source });
        const [{ name, params, returns }] = comment;
        const parameters = params.reduce((acc, cur) => (Object.assign(Object.assign({}, acc), { [cur.name]: cur.type.names })), {});
        const returnType = returns.reduce((acc, curr) => {
            return acc.concat(curr.type.names);
        }, []);
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        const hasComment = foundComments.some((f) => Boolean(f[name]));
        if (!hasComment) {
            foundComments.push({ [name]: { parameters, returnType } });
        }
    });
    return node.forEachChild(child => walkCompilerAstAndFindComments(child, foundComments));
}
exports.walkCompilerAstAndFindComments = walkCompilerAstAndFindComments;
function createParams(params) {
    return Object.entries(params).map(([key, value]) => {
        const result = Array.isArray(value)
            ? ts.createArrayLiteral(value.map(n => ts.createStringLiteral(n)))
            : ts.createObjectLiteral(createParams(value));
        return ts.createPropertyAssignment(ts.createStringLiteral(key), result);
    });
}
function createLiteralObjectExpression(params) {
    return params.map(param => {
        const [[key, value]] = Object.entries(param);
        return ts.createPropertyAssignment(ts.createStringLiteral(key), ts.createObjectLiteral(createParams(value)));
    });
}
exports.createLiteralObjectExpression = createLiteralObjectExpression;
//# sourceMappingURL=comments.js.map