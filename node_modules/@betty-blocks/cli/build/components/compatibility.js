"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("typescript");
const comments_1 = require("./comments");
const isComponentCompatibility = (value) => {
    if (typeof value === 'object' && value !== null) {
        const { functions, triggers } = value;
        if (Array.isArray(functions) && Array.isArray(triggers)) {
            return (functions.every(f => typeof f === 'string') &&
                triggers.every(t => typeof t === 'string'));
        }
    }
    return false;
};
const addCompatibility = (name, collection, node) => {
    if ((typescript_1.isIdentifier(node) && node.getText() === name) ||
        (typescript_1.isPropertyAccessExpression(node) &&
            (node.getText() === `B.${name}` || node.getText() === `.${name}`))) {
        if (typescript_1.isCallExpression(node.parent)) {
            collection.push(node.parent
                .getChildAt(2)
                .getChildAt(0)
                .getText()
                .replace(/'/g, ''));
        }
        if (typescript_1.isMethodDeclaration(node.parent)) {
            collection.push(node.parent
                .getChildAt(2)
                .getChildAt(1)
                .getText()
                .replace(/'/g, ''));
        }
    }
};
const compatibilityTransformer = () => (context) => {
    const functions = [];
    const triggers = [];
    const comments = [];
    const visit = (node) => {
        addCompatibility('defineFunction', functions, node);
        addCompatibility('triggerEvent', triggers, node); // TODO: investigate inline triggers
        return typescript_1.visitEachChild(node, visit, context);
    };
    return (node) => {
        typescript_1.visitNode(node, visit);
        comments_1.walkCompilerAstAndFindComments(node, comments);
        if (typescript_1.isSourceFile(node)) {
            // eslint-disable-next-line no-param-reassign
            node.statements = typescript_1.createNodeArray([
                typescript_1.createStatement(typescript_1.createObjectLiteral([
                    typescript_1.createPropertyAssignment(typescript_1.createStringLiteral('functions'), typescript_1.createArrayLiteral(functions.map(n => typescript_1.createStringLiteral(n)))),
                    typescript_1.createPropertyAssignment(typescript_1.createStringLiteral('triggers'), typescript_1.createArrayLiteral(triggers.map(n => typescript_1.createStringLiteral(n)))),
                    typescript_1.createPropertyAssignment(typescript_1.createStringLiteral('interactions'), typescript_1.createObjectLiteral(comments_1.createLiteralObjectExpression(comments))),
                ])),
            ]);
        }
        return node;
    };
};
exports.default = (code) => {
    const { outputText } = typescript_1.transpileModule(code, {
        transformers: { before: [compatibilityTransformer()] },
    });
    const component = JSON.parse(outputText.replace(/^[^{]+/, '').replace(/[^}]+$/, ''));
    if (isComponentCompatibility(component)) {
        return component;
    }
    throw new TypeError('object is not a ComponentCompatibility');
};
//# sourceMappingURL=compatibility.js.map