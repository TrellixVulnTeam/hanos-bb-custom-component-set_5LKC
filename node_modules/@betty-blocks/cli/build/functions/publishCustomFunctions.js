"use strict";
/* eslint-disable camelcase */
/* eslint-disable @typescript-eslint/camelcase */
/* npm dependencies */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_extra_1 = __importDefault(require("fs-extra"));
const ora_1 = __importDefault(require("ora"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const vm_1 = __importDefault(require("vm"));
/* internal dependencies */
const ide_1 = __importDefault(require("../utils/ide"));
const config_1 = __importDefault(require("./config"));
const publishFunctions_1 = require("./publishFunctions");
/* execute command */
const workingDir = process.cwd();
const groomMetaData = (config) => __awaiter(void 0, void 0, void 0, function* () {
    console.log('Grooming functions.json ...');
    const buildDir = path_1.default.join(os_1.default.tmpdir(), config.identifier);
    const customJsFile = path_1.default.join(buildDir, 'dist', 'custom.js');
    const customJs = fs_extra_1.default.readFileSync(customJsFile, 'utf8');
    const script = new vm_1.default.Script(`${customJs}; fn = custom;`);
    const ctx = { fn: {} };
    script.runInNewContext(ctx);
    const customFunctions = ctx.fn;
    const functionsJsonFile = path_1.default.join(workingDir, 'functions.json');
    const metaData = fs_extra_1.default.readJsonSync(functionsJsonFile);
    const groomedMetaData = yield Object.keys(customFunctions).reduce((promise, name) => __awaiter(void 0, void 0, void 0, function* () {
        return promise.then((groomed) => __awaiter(void 0, void 0, void 0, function* () {
            // eslint-disable-next-line no-param-reassign
            groomed[name] = metaData[name];
            if (!groomed[name]) {
                const matches = customFunctions[name]
                    .toString()
                    .match(/await context\((["'])(.*?)\1\)/g);
                const defaultInputVariables = (matches || [])
                    .map(m => `${m.slice(15, -2)}:string`)
                    .join(' ');
                // eslint-disable-next-line no-param-reassign
                groomed = yield publishFunctions_1.resolveMissingFunction(groomed, metaData, name, defaultInputVariables);
            }
            return groomed;
        }));
    }), Promise.resolve({}));
    fs_extra_1.default.writeFileSync(functionsJsonFile, JSON.stringify(groomedMetaData, null, 2));
    return groomedMetaData;
});
const publishFunctions = (config, metaData, bumpRevision) => __awaiter(void 0, void 0, void 0, function* () {
    const ide = new ide_1.default(config);
    const revision = yield publishFunctions_1.storeCustomFunctions(ide, metaData, bumpRevision);
    const buildDir = path_1.default.join(os_1.default.tmpdir(), config.identifier);
    const customJsFile = path_1.default.join(buildDir, 'dist', 'custom.js');
    yield ide.post(`custom_functions/${revision}`, { multiPartData: [{ name: 'code', file: customJsFile }] }, `Uploading "${revision}.js" ...`);
    const actions = (yield ide.get('actions'));
    yield actions.reduce((promise, { id, use_new_runtime, description }) => __awaiter(void 0, void 0, void 0, function* () {
        yield promise;
        if (use_new_runtime) {
            return ide.put(`actions/${id}`, { json: { record: { description } } }, `Compiling action "${description}" ...`);
        }
        return Promise.resolve(null);
    }), Promise.resolve(null));
});
const cleanMetaData = () => __awaiter(void 0, void 0, void 0, function* () {
    const functionsJsonFile = path_1.default.join(workingDir, 'functions.json');
    const metaData = fs_extra_1.default.readJsonSync(functionsJsonFile);
    Object.keys(metaData).forEach(name => {
        delete metaData[name].replace;
    });
    fs_extra_1.default.writeFileSync(functionsJsonFile, JSON.stringify(metaData, null, 2));
});
const publishCustomFunctions = (host, bumpRevision, skipBuild) => {
    const config = new config_1.default();
    console.log(`Publishing to ${config.host} (${config.zone}) ...`);
    new Promise((resolve) => {
        if (skipBuild) {
            resolve(undefined);
        }
        else {
            const building = ora_1.default(`Building custom functions bundle (this can take a while) ...`).start();
            const build = child_process_1.spawn('bb functions build', {
                shell: true,
            });
            build.on('close', () => {
                building.succeed();
                resolve(undefined);
            });
        }
    })
        .then(() => groomMetaData(config))
        .then((metaData) => publishFunctions(config, metaData, bumpRevision))
        .then(cleanMetaData)
        .then(() => {
        console.log('Done.');
    })
        .catch((err) => {
        console.log(`${err}\nAbort.`);
        process.exit();
    });
};
exports.default = publishCustomFunctions;
//# sourceMappingURL=publishCustomFunctions.js.map