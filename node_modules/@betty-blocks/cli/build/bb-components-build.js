"use strict";
/* npm dependencies */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = __importDefault(require("commander"));
const fs_extra_1 = require("fs-extra");
const compatibility_1 = __importDefault(require("./components/compatibility"));
const compatibility_2 = __importDefault(require("./interactions/compatibility"));
const diagnostics_1 = __importDefault(require("./interactions/diagnostics"));
const arguments_1 = require("./utils/arguments");
const checkUpdateAvailable_1 = require("./utils/checkUpdateAvailable");
const hash_1 = __importDefault(require("./utils/hash"));
const readFilesByType_1 = __importDefault(require("./utils/readFilesByType"));
const transpile_1 = __importDefault(require("./utils/transpile"));
const validation_1 = require("./utils/validation");
/* internal dependencies */
const component_1 = __importDefault(require("./validations/component"));
const interaction_1 = __importDefault(require("./validations/interaction"));
const prefab_1 = __importDefault(require("./validations/prefab"));
/* npm dependencies */
const { mkdir, readFile } = fs_extra_1.promises;
/* process arguments */
commander_1.default
    .usage('[path]')
    .name('bb components build')
    .parse(process.argv);
const { args } = commander_1.default;
const rootDir = arguments_1.parseDir(args);
const distDir = `${rootDir}/dist`;
/* execute command */
const readComponents = () => __awaiter(void 0, void 0, void 0, function* () {
    const srcDir = `${rootDir}/src/components`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        throw new Error(chalk_1.default.red('\nComponents folder not found\n'));
    }
    const componentFiles = yield readFilesByType_1.default(srcDir);
    const components = componentFiles.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const code = yield readFile(`${srcDir}/${file}`, 'utf-8');
            const compatibility = compatibility_1.default(code);
            // eslint-disable-next-line no-new-func
            const transpiledFunction = Function(`return ${transpile_1.default(code, ['jsx', 'styles'])}`)();
            if (!transpiledFunction) {
                throw new Error("Component doesn't return anything");
            }
            return Object.assign(Object.assign({}, transpiledFunction), compatibility);
        }
        catch (error) {
            error.file = file;
            throw error;
        }
    }));
    return Promise.all(components);
});
const readPrefabs = () => __awaiter(void 0, void 0, void 0, function* () {
    const srcDir = `${rootDir}/src/prefabs`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        throw new Error(chalk_1.default.red('\nPrefabs folder not found\n'));
    }
    const prefabFiles = yield readFilesByType_1.default(srcDir);
    const prefabs = prefabFiles.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const code = yield readFile(`${srcDir}/${file}`, 'utf-8');
            // eslint-disable-next-line no-new-func
            const transpiledFunction = Function(`return ${transpile_1.default(code, ['beforeCreate'])}`)();
            if (!transpiledFunction) {
                throw new Error("Prefab doesn't return anything");
            }
            return transpiledFunction;
        }
        catch (error) {
            error.file = file;
            throw error;
        }
    }));
    return Promise.all(prefabs);
});
const readInteractions = () => __awaiter(void 0, void 0, void 0, function* () {
    const srcDir = `${rootDir}/src/interactions`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        return new Promise((resolve) => {
            resolve([]);
        });
    }
    const interactionFiles = yield readFilesByType_1.default(srcDir, 'ts');
    return Promise.all(interactionFiles.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const code = yield readFile(`${srcDir}/${file}`, 'utf-8');
            diagnostics_1.default(`${srcDir}/${file}`);
            return Object.assign({ 
                // failing because it's a keyword
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore
                function: code }, compatibility_2.default(`${srcDir}/${file}`));
        }
        catch (error) {
            error.file = file;
            throw error;
        }
    })));
});
(() => __awaiter(void 0, void 0, void 0, function* () {
    yield checkUpdateAvailable_1.checkUpdateAvailableCLI();
    try {
        const [prefabs, components, interactions] = yield Promise.all([
            readPrefabs(),
            readComponents(),
            readInteractions(),
        ]);
        validation_1.checkNameReferences(prefabs, components);
        yield Promise.all([
            component_1.default(components),
            prefab_1.default(prefabs),
            interactions && interaction_1.default(interactions),
        ]);
        const componentsWithHash = components.map(component => {
            return Object.assign(Object.assign({}, component), { componentHash: hash_1.default(component) });
        });
        const prefabsWithHash = prefabs.map(prefab => {
            const hashStructure = (structure) => {
                const newStructure = Object.assign(Object.assign({}, structure), { hash: hash_1.default(structure.options) });
                if (newStructure.descendants && newStructure.descendants.length > 0) {
                    newStructure.descendants = newStructure.descendants.map(hashStructure);
                }
                return newStructure;
            };
            return Object.assign(Object.assign({}, prefab), { structure: prefab.structure.map(hashStructure) });
        });
        yield mkdir(distDir, { recursive: true });
        const defaultPrefabs = prefabsWithHash.filter(prefab => prefab.type !== 'page');
        const outputPromises = [
            fs_extra_1.outputJson(`${distDir}/prefabs.json`, defaultPrefabs),
            fs_extra_1.outputJson(`${distDir}/templates.json`, componentsWithHash),
            interactions && fs_extra_1.outputJson(`${distDir}/interactions.json`, interactions),
        ];
        const pagePrefabs = prefabs.filter(prefab => prefab.type === 'page');
        if (pagePrefabs.length > 0) {
            outputPromises.push(fs_extra_1.outputJson(`${distDir}/pagePrefabs.json`, pagePrefabs));
        }
        if (pagePrefabs.length === 0 && fs_extra_1.pathExists(`${distDir}/pagePrefabs.json`)) {
            fs_extra_1.remove(`${distDir}/pagePrefabs.json`);
        }
        yield Promise.all(outputPromises);
        console.info(chalk_1.default.green('Success, the component set has been built'));
    }
    catch ({ file, name, message }) {
        process.exitCode = 1;
        if (file) {
            console.error(chalk_1.default.red(`\n${name} in ${file}: ${message}\n`));
        }
        else {
            console.error(chalk_1.default.red(`\n${name}: ${message}\n`));
        }
    }
}))();
//# sourceMappingURL=bb-components-build.js.map