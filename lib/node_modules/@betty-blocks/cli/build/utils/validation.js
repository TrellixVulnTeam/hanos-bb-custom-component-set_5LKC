"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
function fromStructure(object, structure) {
    if (typeof structure === 'string') {
        const value = object[structure];
        if (typeof value === 'string' || typeof value === 'undefined') {
            return value;
        }
    }
    const [[k, v]] = Object.entries(structure);
    return fromStructure(object[k], v);
}
exports.findDuplicates = (list, type, structure) => {
    list.reduce((acc, item) => {
        let value;
        try {
            value = fromStructure(item, structure);
        }
        catch (_a) {
            // all is well in the world
        }
        if (typeof value === 'string') {
            const valueLower = value.toLowerCase();
            if (acc.has(valueLower)) {
                throw new Error(chalk_1.default.red(`\nThe name "${valueLower}" is used for multiple ${type}s\n`));
            }
            acc.add(valueLower);
        }
        return acc;
    }, new Set());
};
const checkComponentReferenceNames = (names, prefabName) => ({ name, descendants }) => {
    if (!names.has(name)) {
        throw new Error(chalk_1.default.red(`\nPrefab: ${prefabName} references to non-existing component "${name}"\n`));
    }
    descendants.forEach(checkComponentReferenceNames(names, prefabName));
};
exports.checkNameReferences = (prefabs, components) => {
    const componentNames = new Set(components.map(({ name }) => name));
    prefabs.forEach(({ name, structure }) => {
        structure.forEach(checkComponentReferenceNames(componentNames, name));
    });
};
//# sourceMappingURL=validation.js.map