"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const util_1 = require("util");
const child_process_1 = require("child_process");
const path_1 = require("path");
const os_1 = require("os");
const semver_1 = require("semver");
const chalk_1 = __importDefault(require("chalk"));
// eslint-disable-next-line
const { version: versionCLI, name: nameCLI } = require('../../package.json');
const execPromise = util_1.promisify(child_process_1.exec);
const TEMP_FOLDER = `${os_1.tmpdir()}/bettyblocks`;
const logUpdateAvailable = (localVersion, remoteVersion, name) => {
    if (semver_1.lt(localVersion, remoteVersion)) {
        console.log(`${name} update available from ${chalk_1.default.greenBright(localVersion)} to ${chalk_1.default.greenBright(remoteVersion)}`);
    }
};
const getRemoteVersionCLI = () => __awaiter(void 0, void 0, void 0, function* () {
    const { stdout: output, stderr: error } = yield execPromise(`npm show @betty-blocks/cli version`);
    const remoteVersionCLI = output.toString().trim();
    if (error) {
        throw error;
    }
    return remoteVersionCLI;
});
const getRemoteVersionPreview = () => __awaiter(void 0, void 0, void 0, function* () {
    const { stdout: output, stderr: error } = yield execPromise(`npm show @betty-blocks/preview version`);
    const remoteVersionPreview = output.toString().trim();
    if (error) {
        throw error;
    }
    return remoteVersionPreview;
});
const writeToFile = () => __awaiter(void 0, void 0, void 0, function* () {
    const remoteVersionCLI = yield getRemoteVersionCLI();
    const remoteVersionPreview = yield getRemoteVersionPreview();
    yield fs_extra_1.writeJson(`${TEMP_FOLDER}/versions.json`, {
        versions: {
            remoteVersionCLI,
            remoteVersionPreview,
        },
        timestamp: Date.now(),
    });
});
const readFile = () => __awaiter(void 0, void 0, void 0, function* () {
    const folderExist = yield fs_extra_1.pathExists(TEMP_FOLDER);
    let remoteVersion;
    if (!folderExist) {
        yield fs_extra_1.mkdir(TEMP_FOLDER);
    }
    const fileExist = yield fs_extra_1.pathExists(`${TEMP_FOLDER}/versions.json`);
    if (fileExist) {
        const { versions, timestamp } = yield fs_extra_1.readJson(`${TEMP_FOLDER}/versions.json`);
        if (timestamp + 86400000 < Date.now()) {
            console.log('Checking for new versions..');
            yield writeToFile();
            remoteVersion = yield readFile();
            console.log('Done');
        }
        remoteVersion = versions;
    }
    else {
        yield writeToFile();
        remoteVersion = yield readFile();
    }
    return remoteVersion;
});
exports.checkUpdateAvailableCLI = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const { remoteVersionCLI } = yield readFile();
        logUpdateAvailable(versionCLI, remoteVersionCLI, nameCLI);
    }
    catch (_a) {
        console.error('Unable to check for a new version');
    }
});
exports.checkUpdateAvailablePreview = (path) => __awaiter(void 0, void 0, void 0, function* () {
    const previewPkg = path_1.join(path, '../package.json');
    try {
        const { version: localVersion, name } = yield fs_extra_1.readJson(previewPkg);
        const { remoteVersionPreview, remoteVersionCLI } = yield readFile();
        logUpdateAvailable(versionCLI, remoteVersionCLI, nameCLI);
        logUpdateAvailable(localVersion, remoteVersionPreview, name);
    }
    catch (_b) {
        console.error('Unable to check for a new version');
    }
});
//# sourceMappingURL=checkUpdateAvailable.js.map